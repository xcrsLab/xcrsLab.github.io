<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习笔记 | xcrsLab</title><meta name="description" content="源码到类文件编译过程Test.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树&#x2F;抽象语法树 -&gt; 语义分析器-&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Test.class文件 .class字节码文件内容魔数与class文件版本常量池访问标志类索引、父类索引、接口索引字段表集合方法表集合属性表集合 类加载器类经过j"><meta name="author" content="xcr"><meta name="copyright" content="xcr"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/Diamond-Sword.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM学习笔记"><meta name="twitter:description" content="源码到类文件编译过程Test.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树&#x2F;抽象语法树 -&gt; 语义分析器-&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Test.class文件 .class字节码文件内容魔数与class文件版本常量池访问标志类索引、父类索引、接口索引字段表集合方法表集合属性表集合 类加载器类经过j"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习笔记"><meta property="og:url" content="http://yoursite.com/2020/08/17/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="xcrsLab"><meta property="og:description" content="源码到类文件编译过程Test.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树&#x2F;抽象语法树 -&gt; 语义分析器-&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Test.class文件 .class字节码文件内容魔数与class文件版本常量池访问标志类索引、父类索引、接口索引字段表集合方法表集合属性表集合 类加载器类经过j"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-08-17T10:58:04.613Z"><meta property="article:modified_time" content="2020-08-17T10:57:43.098Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/08/17/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="prev" title="原型模式学习笔记" href="http://yoursite.com/2020/08/18/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="next" title="Redis学习笔记" href="http://yoursite.com/2020/08/06/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/word.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#源码到类文件"><span class="toc-number">1.</span> <span class="toc-text">源码到类文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编译过程"><span class="toc-number">1.1.</span> <span class="toc-text">编译过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class字节码文件内容"><span class="toc-number">1.2.</span> <span class="toc-text">.class字节码文件内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载器"><span class="toc-number">2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#种类"><span class="toc-number">2.1.</span> <span class="toc-text">种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动类加载器-Bootstrap-ClassLoader"><span class="toc-number">2.1.1.</span> <span class="toc-text">启动类加载器(Bootstrap ClassLoader)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展类加载器-Extension-ClassLoader"><span class="toc-number">2.1.2.</span> <span class="toc-text">拓展类加载器(Extension ClassLoader)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用类加载器-System-ClassLoader"><span class="toc-number">2.1.3.</span> <span class="toc-text">应用类加载器(System ClassLoader)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义加载器（Custom-ClassLoader）"><span class="toc-number">2.1.4.</span> <span class="toc-text">自定义加载器（Custom ClassLoader）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例"><span class="toc-number">2.2.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见问题"><span class="toc-number">2.3.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三大特性"><span class="toc-number">2.4.</span> <span class="toc-text">三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#委托性"><span class="toc-number">2.4.1.</span> <span class="toc-text">委托性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性"><span class="toc-number">2.4.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单一性"><span class="toc-number">2.4.3.</span> <span class="toc-text">单一性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">2.5.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码"><span class="toc-number">2.5.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">2.5.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#破坏"><span class="toc-number">2.5.3.</span> <span class="toc-text">破坏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#沙箱安全机制"><span class="toc-number">2.6.</span> <span class="toc-text">沙箱安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM表示两个完全相同的类"><span class="toc-number">2.6.1.</span> <span class="toc-text">JVM表示两个完全相同的类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM内存模型图"><span class="toc-number">3.</span> <span class="toc-text">JVM内存模型图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行时数据区域"><span class="toc-number">4.</span> <span class="toc-text">运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序计数器（The-PC-Register）"><span class="toc-number">4.1.</span> <span class="toc-text">程序计数器（The PC Register）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">4.1.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈（Java-Virtual-Machine-Stacks）"><span class="toc-number">4.2.</span> <span class="toc-text">虚拟机栈（Java Virtual Machine Stacks）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量表"><span class="toc-number">4.2.1.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作数栈"><span class="toc-number">4.2.2.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态链接"><span class="toc-number">4.2.3.</span> <span class="toc-text">动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法出口"><span class="toc-number">4.2.4.</span> <span class="toc-text">方法出口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区（Method-Area）"><span class="toc-number">4.3.</span> <span class="toc-text">方法区（Method Area）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明"><span class="toc-number">4.3.1.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆（Heap）"><span class="toc-number">4.4.</span> <span class="toc-text">堆（Heap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native-Method-Stacks-本地方法栈"><span class="toc-number">4.5.</span> <span class="toc-text">Native Method Stacks(本地方法栈)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存模型"><span class="toc-number">5.</span> <span class="toc-text">内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java对象内存分布"><span class="toc-number">5.1.</span> <span class="toc-text">Java对象内存分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机内存模型"><span class="toc-number">5.2.</span> <span class="toc-text">虚拟机内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Survivors区机制"><span class="toc-number">5.3.</span> <span class="toc-text">Survivors区机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Old区机制"><span class="toc-number">5.4.</span> <span class="toc-text">Old区机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见问题-1"><span class="toc-number">5.5.</span> <span class="toc-text">常见问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收（Garbage-Collect）"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收（Garbage Collect）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾对象的确定"><span class="toc-number">6.1.</span> <span class="toc-text">垃圾对象的确定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引用计数法"><span class="toc-number">6.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可达性分析"><span class="toc-number">6.1.2.</span> <span class="toc-text">可达性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集算法"><span class="toc-number">6.1.3.</span> <span class="toc-text">垃圾收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-清除-Mark-Sweep）"><span class="toc-number">6.1.4.</span> <span class="toc-text">标记-清除(Mark-Sweep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制算法-Copying"><span class="toc-number">6.1.5.</span> <span class="toc-text">复制算法(Copying)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-整理算法（Mark-Compact）"><span class="toc-number">6.1.6.</span> <span class="toc-text">标记-整理算法（Mark-Compact）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分代收集算法"><span class="toc-number">6.2.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收器"><span class="toc-number">6.3.</span> <span class="toc-text">垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM参数"><span class="toc-number">7.</span> <span class="toc-text">JVM参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常用命令"><span class="toc-number">7.1.</span> <span class="toc-text">常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jps"><span class="toc-number">7.1.1.</span> <span class="toc-text">jps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jinfo"><span class="toc-number">7.1.2.</span> <span class="toc-text">jinfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstat"><span class="toc-number">7.1.3.</span> <span class="toc-text">jstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack"><span class="toc-number">7.1.4.</span> <span class="toc-text">jstack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmap"><span class="toc-number">7.1.5.</span> <span class="toc-text">jmap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用工具"><span class="toc-number">7.2.</span> <span class="toc-text">常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jconsole"><span class="toc-number">7.2.1.</span> <span class="toc-text">jconsole</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvisualvm"><span class="toc-number">7.2.2.</span> <span class="toc-text">jvisualvm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arthas"><span class="toc-number">7.2.3.</span> <span class="toc-text">Arthas</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调优"><span class="toc-number">8.</span> <span class="toc-text">调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集器选择"><span class="toc-number">8.1.</span> <span class="toc-text">垃圾收集器选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#是否选用G1垃圾收集器的判断依据"><span class="toc-number">8.1.1.</span> <span class="toc-text">是否选用G1垃圾收集器的判断依据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM性能优化"><span class="toc-number">8.2.</span> <span class="toc-text">JVM性能优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常见问题思考"><span class="toc-number">9.</span> <span class="toc-text">常见问题思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄漏与内存溢出的区别"><span class="toc-number">9.1.</span> <span class="toc-text">内存泄漏与内存溢出的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#young-gc会有stw吗？"><span class="toc-number">9.2.</span> <span class="toc-text">young gc会有stw吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#major-gc和full-gc的区别"><span class="toc-number">9.3.</span> <span class="toc-text">major gc和full gc的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是直接内存"><span class="toc-number">9.4.</span> <span class="toc-text">什么是直接内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不可达的对象一定要被回收吗？"><span class="toc-number">9.5.</span> <span class="toc-text">不可达的对象一定要被回收吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区中的无用类回收"><span class="toc-number">9.5.1.</span> <span class="toc-text">方法区中的无用类回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同的引用"><span class="toc-number">9.5.2.</span> <span class="toc-text">不同的引用</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">xcrsLab</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JVM学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-08-17 18:58:04"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-08-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-08-17 18:57:43"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-08-17</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="源码到类文件"><a href="#源码到类文件" class="headerlink" title="源码到类文件"></a>源码到类文件</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>Test.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器<br>-&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Test.class文件</p>
<h2 id="class字节码文件内容"><a href="#class字节码文件内容" class="headerlink" title=".class字节码文件内容"></a>.class字节码文件内容</h2><p>魔数与class文件版本<br>常量池<br>访问标志<br>类索引、父类索引、接口索引<br>字段表集合<br>方法表集合<br>属性表集合</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类经过javac编译后，生成.class文件保存下来，然后经过类加载器加载类至内存，生成java.lang.Class类的实例,这个实例就是程序访问这个类的入口，通过这个class实例的newInstance方法即可得到这个类的实例对象</p>
<h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><h3 id="启动类加载器-Bootstrap-ClassLoader"><a href="#启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="启动类加载器(Bootstrap ClassLoader)"></a>启动类加载器(Bootstrap ClassLoader)</h3><p>又称为引导类加载器,由C++编写，无法通过程序得到。主要负责加载JAVA中的一些核心类库，主要是位于<JAVA_HOME>/lib/rt.jar中</p>
<h3 id="拓展类加载器-Extension-ClassLoader"><a href="#拓展类加载器-Extension-ClassLoader" class="headerlink" title="拓展类加载器(Extension ClassLoader)"></a>拓展类加载器(Extension ClassLoader)</h3><p>主要加载JAVA中的一些拓展类，位于<JAVA_HOME>/lib/ext中,是启动类加载器                                                           的子类。</p>
<h3 id="应用类加载器-System-ClassLoader"><a href="#应用类加载器-System-ClassLoader" class="headerlink" title="应用类加载器(System ClassLoader)"></a>应用类加载器(System ClassLoader)</h3><p>又称为系统类加载器,主要用于加载CLASSPATH路径下我们自己写的类，是拓展类                                                                       加载器的子类</p>
<h3 id="自定义加载器（Custom-ClassLoader）"><a href="#自定义加载器（Custom-ClassLoader）" class="headerlink" title="自定义加载器（Custom ClassLoader）"></a>自定义加载器（Custom ClassLoader）</h3><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>当我们自己编写一个类，名为Test，经过编译后会得到Test.class文件，然后经过类加载器得到Class实例，例如通过Class.forName(“com.***.Test”),通过全路径加载进来。</p>
<ol>
<li>用Test.class.getClassLoader()得到它的类加载器，得到的是AppClassLoader(即系统类加载器)</li>
<li>如果用Test.class.getClassLoader().getParent()得到的是它的父加载器ExtClassLoader（即拓展类加载器）</li>
<li>用Test.class.getClassLoader().getParent().getParent()得到将会是Null，因为启动类加载器是用C++写的，我们无法通过程序直接得到</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>Object类是由哪个类加载器加载的?<br>BootStrap ClassLoader<ol start="2">
<li>我们自己写的类是由哪个类加载器加载的?<br>System ClassLoader</li>
<li>类加载器都是我们Java中的一个类ClassLoader的子类吗?<br>BootStrap ClassLoader不是的，另外两个是的。<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="委托性"><a href="#委托性" class="headerlink" title="委托性"></a>委托性</h3>每个类中都有一个自己的类加载器的属性，这也就是为什么可以通过Test.class.getClassLoader()来    获取自己的类加载器。当一个类加载器要加载一个类时，它会先委托自己的父类加载器来加载，只有当父加载器无法加载类时，才会自己去加载。例如我们写了一个类Student,它的类加载器是System ClassLoader,它首先会委托给它的父加载器即Extension ClassLoader,然后Extension ClassLoader又会委托给它的父加载器BootStrap ClassLoader,启动类加载器无法加载这个类，交给拓展类加载器，拓展类加载器也无法加载，然后才轮到系统类加载器进行加载。<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3>可见性指的是父加载器无法利用子加载器加载的类，而子加载器可以利用父加载器加载的类。<h3 id="单一性"><a href="#单一性" class="headerlink" title="单一性"></a>单一性</h3>一个类只会被一个类加载器加载一次，不会被重复加载。</li>
</ol>
</li>
</ol>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类</p>
<p><img src="https://img-blog.csdnimg.cn/20200811141440781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">    </p>
<ul>
<li><p>首先判断了该类是否已加载.</p>
</li>
<li><p>若没加载,则传给双亲加载器去加载,</p>
</li>
<li><p>若双亲加载器没能成功加载它,则自己用findClass()去加载.所以是个向上递归的过程.</p>
</li>
<li><p>自定义加载器时,需要重写findClass方法,因为是空的,没有任何内容:</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200811151314144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//              -----??-----</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li><p>保证安全性<br>防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</p>
</li>
<li><p>保证唯一性</p>
<pre><code>保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。</code></pre></li>
</ol>
<p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，但是在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以并不会再去加载，从一定程度上防止了危险代码的植入</p>
<h3 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h3><p>可以继承ClassLoader类，然后重写其中的loadClass方法，其他方式大家可以自己了解<br>拓展一下</p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例：定义一个String类</span></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Im String"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://img-blog.csdnimg.cn/20200811160044781.png" alt="在这里插入图片描述"><br>保护Java核心源代码这种机制就称之为沙箱安全机制</p>
<h3 id="JVM表示两个完全相同的类"><a href="#JVM表示两个完全相同的类" class="headerlink" title="JVM表示两个完全相同的类"></a>JVM表示两个完全相同的类</h3><ol>
<li>类的全限定类名必须完全一致</li>
<li>加载这个类的ClassLoader必须完全一致(我们新建的String引导类加载器不会加载)<h1 id="JVM内存模型图"><a href="#JVM内存模型图" class="headerlink" title="JVM内存模型图"></a>JVM内存模型图</h1><img src="https://img-blog.csdnimg.cn/202007241450097.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><h2 id="程序计数器（The-PC-Register）"><a href="#程序计数器（The-PC-Register）" class="headerlink" title="程序计数器（The PC Register）"></a>程序计数器（The PC Register）</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3>当前线程所执行的字节码的行号指示器。<br>分支、循环、跳转、异常处理、线程恢复等基础功能都依赖该指示器的记录完成<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li>
<li>线程私有，每个线程都需要独立的程序计数器</li>
<li>如果当前线程正在执行java方法，计数器记录正在执行的虚拟机字节码指令的地址</li>
<li>如果正在执行native方法，计数器值为空</li>
<li>占用内存空间少，没有规定内存溢出</li>
</ol>
<h2 id="虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="虚拟机栈（Java Virtual Machine Stacks）"></a>虚拟机栈（Java Virtual Machine Stacks）</h2><ol>
<li>虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个Java线程的运行状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。</li>
<li>每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。</li>
<li>调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出<br><img src="https://img-blog.csdnimg.cn/20200727160651655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3>局部变量表(Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。<br>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。<br>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3>操作数栈(Operand Stack）也常称为操作栈<br>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写人和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)<h3 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h3>当一个方法开始执行后,只有两种方式可以退出，一种是遇到方法返回的字节码指令；一种是遇见异常，并且 这个异常没有在方法体内得到处理<h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2></li>
<li>方法区是线程共享的内存区域，在虚拟机启动时创建</li>
<li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
<li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap(非堆)，目的是与Java堆区分开来</li>
<li>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常<br><img src="https://img-blog.csdnimg.cn/20200817122433294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>(1)方法区在JDK 8中就是Metaspace，在JDK6或7中就是Perm Space<br>(2)Run-Time Constant Pool</p>
<h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><ol>
<li>Java堆是Java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享</li>
<li>Java对象实例以及数组都在堆上分配</li>
</ol>
<h2 id="Native-Method-Stacks-本地方法栈"><a href="#Native-Method-Stacks-本地方法栈" class="headerlink" title="Native Method Stacks(本地方法栈)"></a>Native Method Stacks(本地方法栈)</h2><p>如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="Java对象内存分布"><a href="#Java对象内存分布" class="headerlink" title="Java对象内存分布"></a>Java对象内存分布</h2><p><img src="https://img-blog.csdnimg.cn/20200817162514520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="虚拟机内存模型"><a href="#虚拟机内存模型" class="headerlink" title="虚拟机内存模型"></a>虚拟机内存模型</h2><p><img src="https://img-blog.csdnimg.cn/20200817163606970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>一块是非堆区，一块是堆区。</li>
<li>堆区分为两大块，一个是Old区，一个是Young区。</li>
<li>Young区分为两大块，一个是Survivor区（S0+S1），一块是Eden区。 Eden:S0:S1=8:1:1</li>
<li>S0和S1一样大，也可以叫From和To</li>
<li>新创建的对象在Eden区</li>
</ol>
<h2 id="Survivors区机制"><a href="#Survivors区机制" class="headerlink" title="Survivors区机制"></a>Survivors区机制</h2><p>Survivor区分为两块S0和S1，也可以叫做From和To。<br>在同一个时间点上，S0和S1只能有一个区有数据，另外一个是空的（GC机制）</p>
<h2 id="Old区机制"><a href="#Old区机制" class="headerlink" title="Old区机制"></a>Old区机制</h2><p>一般Old区都是年龄比较大的对象，或者相对超过了某个阈值的对象。<br>在Old区也会有GC的操作，Old区的GC我们称作为Major GC。<br>当Old区满时，会出现OutOfMemory异常（内存溢出）</p>
<h2 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>如何理解Minor/Major/Full GC？<br>Minor GC:新生代<br>Major GC:老年代<br>Full GC:新生代+老年代</li>
<li>为什么需要Survivor区?只有Eden不行吗？<br>Survivor的存在意义,就是减少被送到老年代的对象,进而减少Full GC的发生,Survivor的预筛选保证,只有经历16次Minor GC还能在新生代中存活的对象,才会被送到老年代</li>
<li>为什么需要两个Survivor区？<br>最大的好处就是解决了碎片化。也就是说为什么一个Survivor区不行?第一部分中,我们知道了必须设置Survivor区。假设<br>现在只有一个Survivor区,我们来模拟一下流程:<br>刚刚新建的对象在Eden中,一旦Eden满了,触发一次Minor GC,Eden中的存活对象就会被移动到Survivor区。这样继续循<br>环下去,下一次Eden满了的时候,问题来了,此时进行Minor GC,Eden和Survivor各有一些存活对象,如果此时把Eden区的<br>存活对象硬放到Survivor区,很明显这两部分对象所占有的内存是不连续的,也就导致了内存碎片化。<br>永远有一个Survivor space是空的,另一个非空的Survivor space无碎片</li>
<li>新生代中Eden:S1:S2为什么是8:1:1？<br>新生代中的可用内存：复制算法用来担保的内存为9：1<br>可用内存中Eden：S1区为8：1<br>即新生代中Eden:S1:S2 = 8：1：1</li>
</ol>
<h1 id="垃圾回收（Garbage-Collect）"><a href="#垃圾回收（Garbage-Collect）" class="headerlink" title="垃圾回收（Garbage Collect）"></a>垃圾回收（Garbage Collect）</h1><h2 id="垃圾对象的确定"><a href="#垃圾对象的确定" class="headerlink" title="垃圾对象的确定"></a>垃圾对象的确定</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任<br>何指针对其引用，它就是垃圾<br><strong>弊端</strong>：若A与B存在相互引用，则导致永远无法回收</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>通过GC Root的对象，开始向下寻找，看某个对象是否可达</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>已经能够确定一个对象为垃圾之后，接下来要考虑的就是回收，怎么回收呢？<br>得要有对应的算法，下面聊聊常见的垃圾回收算法</p>
<h3 id="标记-清除-Mark-Sweep）"><a href="#标记-清除-Mark-Sweep）" class="headerlink" title="标记-清除(Mark-Sweep）"></a>标记-清除(Mark-Sweep）</h3><ol>
<li><strong>标记</strong>：找出内存中需要回收的对象，并且把它们标记出来，此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时</li>
<li><strong>清楚</strong>：清除掉被标记需要回收的对象，释放出对应的内存空间</li>
</ol>
<p>缺点：<br>3.  标记和清除两个过程都比较耗时，效率不高<br>4. 会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无 法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p>
<h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><p>将内存划分为两块相等的区域，每次只使用其中一块,当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次清除掉<br><img src="https://img-blog.csdnimg.cn/20200817173053286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><strong>缺点</strong>：空间利用率低</p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>标记过程仍然与”标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活<br>的对象都向一端移动，然后直接清理掉端边界以外的内存<br><img src="https://img-blog.csdnimg.cn/20200817173245997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200817173302155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>Young区：复制算法(对象在被分配之后，可能生命周期比较短，Young区复制效率比较高)<br>Old区：标记清除或标记整理(Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理)</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>…</p>
<h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>查看java进程<br><img src="https://img-blog.csdnimg.cn/20200817174440486.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>实时查看和调整JVM配置参数</p>
<ol>
<li>查看<br>查看某个java进程的name属性的值<br>jinfo -flag MaxHeapSize PID<br>jinfo -flag UseG1GC PID<br><img src="https://img-blog.csdnimg.cn/20200817180659806.png#pic_center" alt="在这里插入图片描述"></li>
<li>修改<br>参数只有被标记为manageable的flags可以被实时修改<br>jinfo -flag [+|-] PID<br>jinfo -flag = PID</li>
<li>查看曾经赋过值的一些参数<br>jinfo -flags PID<br><img src="https://img-blog.csdnimg.cn/20200817180640709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3>(1)查看虚拟机性能统计信息<br>(2)查看类装载信息<br>jstat -class PID 1000 10 查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10 次<br><img src="https://img-blog.csdnimg.cn/20200817180830425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>(3)查看垃圾收集信息<br>jstat -gc PID 1000 10<br><img src="https://img-blog.csdnimg.cn/20200817180902396.png#pic_center" alt="在这里插入图片描述"><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3>(1)查看线程堆栈信息<br>(2)用法<br>jstack PID<br><img src="https://img-blog.csdnimg.cn/20200817180951796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3>(1)生成堆转储快照<br>(2)打印出堆内存相关信息</li>
</ol>
<p>-XX:+PrintFlagsFinal -Xms300M -Xmx300M jmap -heap PID<br><img src="https://img-blog.csdnimg.cn/2020081718245218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>(3)dump出堆内存相关信息<br>jmap -dump:format=b,file=heap.hprof PID<br>jmap -dump:format=b,file=heap.hprof 44808<br><img src="https://img-blog.csdnimg.cn/20200817182542277.png#pic_center" alt="在这里插入图片描述"><br>(4)要是在发生堆内存溢出的时候，能自动dump出该文件就好了<br>一般在开发中，JVM参数可以加上下面两句，这样内存溢出时，会自动dump出该文件<br>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof<br>设置堆内存大小: -Xms20M -Xmx20M 启动，然后访问localhost:9090/heap，使得堆内存溢出<br>(5)关于dump下来的文件，一般dump下来的文件可以结合工具来分析</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>JConsole工具是JDK自带的可视化监控工具。查看java应用程序的运行概况、监控堆信息、永久区使用<br>情况、类加载情况等<br>命令行中输入：jconsole</p>
<h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><ol>
<li><p>监控本地Java进程<br>可以监控本地的java进程的CPU，类，线程等</p>
</li>
<li><p>监控远端Java进程<br>(1)在visualvm中选中“远程”，右击“添加”<br>(2)主机名上写服务器的ip地址，比如31.100.39.63，然后点击“确定”<br>(3)右击该主机“31.100.39.63”，添加“JMX”[也就是通过JMX技术具体监控远端服务器哪个Java进程]<br>(4)要想让服务器上的tomcat被连接，需要改一下 bin/catalina.sh 这个文件</p>
<blockquote>
<p>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote - Djava.rmi.server.hostname=31.100.39.63 -Dcom.sun.management.jmxremote.port=8998 -Dcom.sun.management.jmxremote.ssl=false - Dcom.sun.management.jmxremote.authenticate=true - Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access - Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password” g</p>
</blockquote>
<p> (5)在 ../conf 文件中添加两个文件jmxremote.access和jmxremote.password<br> jmxremote.access 文件</p>
<blockquote>
<p>guest readonly<br> manager readwrite</p>
</blockquote>
<p> jmxremote.password 文件</p>
<blockquote>
<p>guest guest<br> manager manager</p>
</blockquote>
<p> 授予权限 : chmod 600 <em>jmxremot</em><br> (6)将连接服务器地址改为公网ip地址</p>
<blockquote>
<p>hostname -i 查看输出情况 </p>
<pre><code>172.26.225.240 172.17.0.1 </code></pre><p> vim /etc/hosts </p>
<pre><code>172.26.255.240 31.100.39.63</code></pre></blockquote>
<p> (7)设置上述端口对应的阿里云安全策略和防火墙策略<br> (8)启动tomcat，来到bin目录<br> (9)查看tomcat启动日志以及端口监听</p>
<blockquote>
<p>tail -f ../logs/catalina.out<br> lsof -i tcp:8080</p>
</blockquote>
<p> (10)查看8998监听情况，可以发现多开了几个端口</p>
<blockquote>
<p>lsof -i:8998 得到PID<br> netstat -antup | grep PID</p>
</blockquote>
<p> (11)在刚才的JMX中输入8998端口，并且输入用户名和密码则登录成功</p>
<blockquote>
<p>端口:8998<br> 用户名:manager<br> 密码:manager</p>
</blockquote>
</li>
</ol>
<h3 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h3><blockquote>
<p>github ：<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></p>
</blockquote>
<p>Arthas 是Alibaba开源的Java诊断工具，采用命令行交互模式，是排查jvm相关问题的利器。<br><img src="https://img-blog.csdnimg.cn/20200817184838245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>下载安装</strong>:</p>
<blockquote>
<p>curl -O <a href="https://alibaba.github.io/arthas/arthas-boot.jar" target="_blank" rel="noopener">https://alibaba.github.io/arthas/arthas-boot.jar</a><br>java -jar arthas-boot.jar<br>然后可以选择一个Java进程</p>
</blockquote>
<p><strong>Print usage</strong></p>
<blockquote>
<p>java -jar arthas-boot.jar -h</p>
</blockquote>
<h1 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h1><h2 id="垃圾收集器选择"><a href="#垃圾收集器选择" class="headerlink" title="垃圾收集器选择"></a>垃圾收集器选择</h2><h3 id="是否选用G1垃圾收集器的判断依据"><a href="#是否选用G1垃圾收集器的判断依据" class="headerlink" title="是否选用G1垃圾收集器的判断依据"></a>是否选用G1垃圾收集器的判断依据</h3><p>（1）50%以上的堆被存活对象占用<br>（2）对象分配和晋升的速度变化非常大<br>（3）垃圾回收时间比较长</p>
<h2 id="JVM性能优化"><a href="#JVM性能优化" class="headerlink" title="JVM性能优化"></a>JVM性能优化</h2><p><img src="https://img-blog.csdnimg.cn/20200817185422166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="常见问题思考"><a href="#常见问题思考" class="headerlink" title="常见问题思考"></a>常见问题思考</h1><h2 id="内存泄漏与内存溢出的区别"><a href="#内存泄漏与内存溢出的区别" class="headerlink" title="内存泄漏与内存溢出的区别"></a>内存泄漏与内存溢出的区别</h2><p>内存泄漏：对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。<br>内存溢出：内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。</p>
<h2 id="young-gc会有stw吗？"><a href="#young-gc会有stw吗？" class="headerlink" title="young gc会有stw吗？"></a>young gc会有stw吗？</h2><p>不管什么 GC，都会有 stop-the-world，只是发生时间的长短。</p>
<h2 id="major-gc和full-gc的区别"><a href="#major-gc和full-gc的区别" class="headerlink" title="major gc和full gc的区别"></a>major gc和full gc的区别</h2><p>major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。 （4）G1与CMS的区别是什么<br>CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。<br>G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。</p>
<h2 id="什么是直接内存"><a href="#什么是直接内存" class="headerlink" title="什么是直接内存"></a>什么是直接内存</h2><p>直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考<br>虑，读写频繁的场合可能会考虑使用直接内存。</p>
<h2 id="不可达的对象一定要被回收吗？"><a href="#不可达的对象一定要被回收吗？" class="headerlink" title="不可达的对象一定要被回收吗？"></a>不可达的对象一定要被回收吗？</h2><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。<br>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<h3 id="方法区中的无用类回收"><a href="#方法区中的无用类回收" class="headerlink" title="方法区中的无用类回收"></a>方法区中的无用类回收</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？<br>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满<br>足下面 3 个条件才能算是 “无用的类” ：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然<br>被回收。</p>
<h3 id="不同的引用"><a href="#不同的引用" class="headerlink" title="不同的引用"></a>不同的引用</h3><p>JDK1.2以后，Java对引用进行了扩充：强引用、软引用、弱引用和虚引用</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">xcr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/08/17/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://yoursite.com/2020/08/17/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/08/18/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">原型模式学习笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/08/06/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Redis学习笔记</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'VJOs4EVRhHLbfnfAm9ezhk2c-gzGzoHsz',
  appKey: 'hQrvQk5qQ0QfLhow1uxyhcub',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By xcr</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>
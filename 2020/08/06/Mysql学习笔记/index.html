<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Mysql学习笔记 | xcrsLab</title><meta name="description" content="@Toc Linux安装Mysql安装安装方法搜索即可，不再赘述 验证安装是否成功rpm -qa|grep -i mysql 查看是否安装过Mysqlps -ef|grep mysql  查看mysql状态cat &#x2F;etc&#x2F;passwd|grep mysql  cat &#x2F;etc&#x2F;group|grep mysql  查看用户组mysqladmin –version  查看mysql版本 启动&#x2F;停止s"><meta name="author" content="xcr"><meta name="copyright" content="xcr"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/Diamond-Sword.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Mysql学习笔记"><meta name="twitter:description" content="@Toc Linux安装Mysql安装安装方法搜索即可，不再赘述 验证安装是否成功rpm -qa|grep -i mysql 查看是否安装过Mysqlps -ef|grep mysql  查看mysql状态cat &#x2F;etc&#x2F;passwd|grep mysql  cat &#x2F;etc&#x2F;group|grep mysql  查看用户组mysqladmin –version  查看mysql版本 启动&#x2F;停止s"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Mysql学习笔记"><meta property="og:url" content="http://yoursite.com/2020/08/06/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="xcrsLab"><meta property="og:description" content="@Toc Linux安装Mysql安装安装方法搜索即可，不再赘述 验证安装是否成功rpm -qa|grep -i mysql 查看是否安装过Mysqlps -ef|grep mysql  查看mysql状态cat &#x2F;etc&#x2F;passwd|grep mysql  cat &#x2F;etc&#x2F;group|grep mysql  查看用户组mysqladmin –version  查看mysql版本 启动&#x2F;停止s"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-08-06T00:57:41.035Z"><meta property="article:modified_time" content="2020-08-06T00:55:58.869Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/08/06/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="prev" title="Redis学习笔记" href="http://yoursite.com/2020/08/06/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="next" title="使用Java语言调用shell脚本重启tomcat" href="http://yoursite.com/2020/05/27/%E4%BD%BF%E7%94%A8Java%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8shell%E8%84%9A%E6%9C%AC%E9%87%8D%E5%90%AFtomcat/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/word.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux安装Mysql"><span class="toc-number">1.</span> <span class="toc-text">Linux安装Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装"><span class="toc-number">1.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#验证安装是否成功"><span class="toc-number">1.2.</span> <span class="toc-text">验证安装是否成功</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动-停止"><span class="toc-number">1.3.</span> <span class="toc-text">启动&#x2F;停止</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MYSQL用户管理"><span class="toc-number">2.</span> <span class="toc-text">MYSQL用户管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#用户管理命令"><span class="toc-number">2.1.</span> <span class="toc-text">用户管理命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户权限查看"><span class="toc-number">2.2.</span> <span class="toc-text">用户权限查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql权限管理"><span class="toc-number">2.3.</span> <span class="toc-text">Mysql权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#赋予权限"><span class="toc-number">2.3.1.</span> <span class="toc-text">赋予权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收回权限"><span class="toc-number">2.3.2.</span> <span class="toc-text">收回权限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql架构"><span class="toc-number">3.</span> <span class="toc-text">Mysql架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#整体架构"><span class="toc-number">3.1.</span> <span class="toc-text">整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#连接层"><span class="toc-number">3.1.1.</span> <span class="toc-text">连接层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务层"><span class="toc-number">3.1.2.</span> <span class="toc-text">服务层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引擎层"><span class="toc-number">3.1.3.</span> <span class="toc-text">引擎层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储层"><span class="toc-number">3.1.4.</span> <span class="toc-text">存储层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#show-profile"><span class="toc-number">3.2.</span> <span class="toc-text">show profile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#开启-profile"><span class="toc-number">3.2.1.</span> <span class="toc-text">开启 profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-profile"><span class="toc-number">3.2.2.</span> <span class="toc-text">使用 profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查询流程"><span class="toc-number">3.2.3.</span> <span class="toc-text">查询流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-和-和-InnoDB"><span class="toc-number">3.2.4.</span> <span class="toc-text">MyISAM 和 和 InnoDB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#索引"><span class="toc-number">4.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特点"><span class="toc-number">4.2.</span> <span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点"><span class="toc-number">4.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点"><span class="toc-number">4.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql索引"><span class="toc-number">4.3.</span> <span class="toc-text">Mysql索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树（B树）"><span class="toc-number">4.3.1.</span> <span class="toc-text">B-树（B树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#规则"><span class="toc-number">4.3.2.</span> <span class="toc-text">规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树-B-tree"><span class="toc-number">4.3.3.</span> <span class="toc-text">B+树(B+tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#规则-1"><span class="toc-number">4.3.4.</span> <span class="toc-text">规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树与B-树区别"><span class="toc-number">4.3.5.</span> <span class="toc-text">B树与B+树区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聚簇索引和非聚簇索引"><span class="toc-number">4.4.</span> <span class="toc-text">聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引分类"><span class="toc-number">4.5.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单值索引"><span class="toc-number">4.5.1.</span> <span class="toc-text">单值索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#唯一索引"><span class="toc-number">4.5.2.</span> <span class="toc-text">唯一索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主键索引"><span class="toc-number">4.5.3.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合索引"><span class="toc-number">4.5.4.</span> <span class="toc-text">复合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引应用场景"><span class="toc-number">4.6.</span> <span class="toc-text">索引应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#适合创建场景"><span class="toc-number">4.6.1.</span> <span class="toc-text">适合创建场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不适合创建的场景"><span class="toc-number">4.6.2.</span> <span class="toc-text">不适合创建的场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Explain性能分析"><span class="toc-number">5.</span> <span class="toc-text">Explain性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念-1"><span class="toc-number">5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#id"><span class="toc-number">5.2.</span> <span class="toc-text">id</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#id-相同"><span class="toc-number">5.2.1.</span> <span class="toc-text">id 相同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#id-不同"><span class="toc-number">5.3.</span> <span class="toc-text">id 不同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#有相同也有不同"><span class="toc-number">5.3.1.</span> <span class="toc-text">有相同也有不同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-type"><span class="toc-number">5.4.</span> <span class="toc-text">select_type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SIMPLE"><span class="toc-number">5.4.1.</span> <span class="toc-text">SIMPLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PRIMARY"><span class="toc-number">5.4.2.</span> <span class="toc-text">PRIMARY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DERIVED"><span class="toc-number">5.4.3.</span> <span class="toc-text">DERIVED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SUBQUERY"><span class="toc-number">5.4.4.</span> <span class="toc-text">SUBQUERY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DEPENDENT-SUBQUERY"><span class="toc-number">5.4.5.</span> <span class="toc-text">DEPENDENT SUBQUERY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNCACHEABLE-SUBQUREY"><span class="toc-number">5.4.6.</span> <span class="toc-text">UNCACHEABLE SUBQUREY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNION"><span class="toc-number">5.4.7.</span> <span class="toc-text">UNION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNION-RESULT"><span class="toc-number">5.4.8.</span> <span class="toc-text">UNION RESULT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table"><span class="toc-number">5.5.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type"><span class="toc-number">5.6.</span> <span class="toc-text">type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#system"><span class="toc-number">5.6.1.</span> <span class="toc-text">system</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">5.6.2.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eq-ref"><span class="toc-number">5.6.3.</span> <span class="toc-text">eq_ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-number">5.6.4.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#range"><span class="toc-number">5.6.5.</span> <span class="toc-text">range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index"><span class="toc-number">5.6.6.</span> <span class="toc-text">index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#all"><span class="toc-number">5.6.7.</span> <span class="toc-text">all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index-merge"><span class="toc-number">5.6.8.</span> <span class="toc-text">index_merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-or-null"><span class="toc-number">5.6.9.</span> <span class="toc-text">ref_or_null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index-subquery"><span class="toc-number">5.6.10.</span> <span class="toc-text">index_subquery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-subquery"><span class="toc-number">5.6.11.</span> <span class="toc-text">unique_subquery</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#possible-keys"><span class="toc-number">5.7.</span> <span class="toc-text">possible_keys</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key"><span class="toc-number">5.8.</span> <span class="toc-text">key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ref-1"><span class="toc-number">5.9.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rows"><span class="toc-number">5.10.</span> <span class="toc-text">rows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extra"><span class="toc-number">5.11.</span> <span class="toc-text">Extra</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-filesort"><span class="toc-number">5.11.1.</span> <span class="toc-text">Using filesort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-temporary"><span class="toc-number">5.11.2.</span> <span class="toc-text">Using temporary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-index"><span class="toc-number">5.11.3.</span> <span class="toc-text">Using index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-where"><span class="toc-number">5.11.4.</span> <span class="toc-text">Using where</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-join-buffer"><span class="toc-number">5.11.5.</span> <span class="toc-text">Using join buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#impossible-where"><span class="toc-number">5.11.6.</span> <span class="toc-text">impossible where</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-tables-optimized-away"><span class="toc-number">5.11.7.</span> <span class="toc-text">select tables optimized away</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#批量脚本"><span class="toc-number">6.</span> <span class="toc-text">批量脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#插入数据"><span class="toc-number">6.1.</span> <span class="toc-text">插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#随机产生字符串"><span class="toc-number">6.1.1.</span> <span class="toc-text">随机产生字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机产生编号"><span class="toc-number">6.1.2.</span> <span class="toc-text">随机产生编号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建存储过程"><span class="toc-number">6.2.</span> <span class="toc-text">创建存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建往-emp-表中插入数据的存储过程"><span class="toc-number">6.2.1.</span> <span class="toc-text">创建往 emp 表中插入数据的存储过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用存储过程"><span class="toc-number">6.3.</span> <span class="toc-text">调用存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#添加数据"><span class="toc-number">6.3.1.</span> <span class="toc-text">添加数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#批量删除某个表上的所有索引"><span class="toc-number">6.4.</span> <span class="toc-text">批量删除某个表上的所有索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#删除索引的存储过程"><span class="toc-number">6.4.1.</span> <span class="toc-text">删除索引的存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行存储过程"><span class="toc-number">6.4.2.</span> <span class="toc-text">执行存储过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单表使用索引常见的索引失效"><span class="toc-number">7.</span> <span class="toc-text">单表使用索引常见的索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#全值匹配"><span class="toc-number">7.1.</span> <span class="toc-text">全值匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#有以下-SQL-语句"><span class="toc-number">7.1.1.</span> <span class="toc-text">有以下 SQL 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建立索引"><span class="toc-number">7.1.2.</span> <span class="toc-text">建立索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最左前置法则"><span class="toc-number">7.2.</span> <span class="toc-text">最左前置法则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要在索引列上做任何计算"><span class="toc-number">7.3.</span> <span class="toc-text">不要在索引列上做任何计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引列不能有范围查询"><span class="toc-number">7.3.1.</span> <span class="toc-text">索引列不能有范围查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#尽量使用覆盖索引"><span class="toc-number">7.4.</span> <span class="toc-text">尽量使用覆盖索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用不等于-或者-lt-gt-的时候"><span class="toc-number">7.4.1.</span> <span class="toc-text">使用不等于(!&#x3D; 或者&lt;&gt;)的时候</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字段的-is-not-null-和-is-null"><span class="toc-number">7.4.2.</span> <span class="toc-text">字段的 is not null 和 is null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#like-的前后模糊匹配"><span class="toc-number">7.4.3.</span> <span class="toc-text">like 的前后模糊匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少使用or"><span class="toc-number">7.4.4.</span> <span class="toc-text">减少使用or</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关联查询优化"><span class="toc-number">8.</span> <span class="toc-text">关联查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#left-join"><span class="toc-number">8.1.</span> <span class="toc-text">left join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inner-join"><span class="toc-number">8.2.</span> <span class="toc-text">inner join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四个关联查询案例分析"><span class="toc-number">8.3.</span> <span class="toc-text">四个关联查询案例分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子查询优化"><span class="toc-number">9.</span> <span class="toc-text">子查询优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序分组优化"><span class="toc-number">10.</span> <span class="toc-text">排序分组优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的字段必须由where或limit处理"><span class="toc-number">10.1.</span> <span class="toc-text">索引的字段必须由where或limit处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顺序错，必排序"><span class="toc-number">10.2.</span> <span class="toc-text">顺序错，必排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方向反，必排序"><span class="toc-number">10.3.</span> <span class="toc-text">方向反，必排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引选择"><span class="toc-number">10.4.</span> <span class="toc-text">索引选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-filesort"><span class="toc-number">10.5.</span> <span class="toc-text">using filesort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql排序算法"><span class="toc-number">10.5.1.</span> <span class="toc-text">mysql排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何优化"><span class="toc-number">10.5.2.</span> <span class="toc-text">如何优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#截取查询分析"><span class="toc-number">11.</span> <span class="toc-text">截取查询分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#慢日志查询"><span class="toc-number">11.1.</span> <span class="toc-text">慢日志查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">11.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么用"><span class="toc-number">11.1.2.</span> <span class="toc-text">怎么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日志分析工具mysqldumpslow"><span class="toc-number">11.1.3.</span> <span class="toc-text">日志分析工具mysqldumpslow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHOW-PROCESSLIST"><span class="toc-number">11.2.</span> <span class="toc-text">SHOW PROCESSLIST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-1"><span class="toc-number">11.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么用-1"><span class="toc-number">11.2.2.</span> <span class="toc-text">怎么用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工具和技巧拾遗"><span class="toc-number">11.3.</span> <span class="toc-text">工具和技巧拾遗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-2"><span class="toc-number">11.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">11.3.2.</span> <span class="toc-text">作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#主从复制"><span class="toc-number">12.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本原理"><span class="toc-number">12.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本原则"><span class="toc-number">12.2.</span> <span class="toc-text">基本原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最大问题"><span class="toc-number">12.3.</span> <span class="toc-text">最大问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一主一从常见配置"><span class="toc-number">12.4.</span> <span class="toc-text">一主一从常见配置</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">xcrsLab</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Mysql学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-08-06 08:57:41"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-08-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-08-06 08:55:58"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-08-06</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>@<a href="Mysql学习笔记">Toc</a></p>
<h1 id="Linux安装Mysql"><a href="#Linux安装Mysql" class="headerlink" title="Linux安装Mysql"></a>Linux安装Mysql</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装方法搜索即可，不再赘述</p>
<h2 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h2><p>rpm -qa|grep -i mysql 查看是否安装过Mysql<br>ps -ef|grep mysql  查看mysql状态<br>cat /etc/passwd|grep mysql  cat /etc/group|grep mysql  查看用户组<br>mysqladmin –version  查看mysql版本</p>
<h2 id="启动-停止"><a href="#启动-停止" class="headerlink" title="启动/停止"></a>启动/停止</h2><p>service mysql start<br>service mysql stop</p>
<h1 id="MYSQL用户管理"><a href="#MYSQL用户管理" class="headerlink" title="MYSQL用户管理"></a>MYSQL用户管理</h1><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><p>create user aaa identified by ‘123456’;   创建名称为zhang3的用户,密码设为 123123；<br>select host,user,password,select_priv,insert_priv,drop_priv from mysql.user 查看用户和权限的相关信息<br>set password =password(‘123456’) 修改当前用户的密码<br>update mysql.user set password=password(‘123456’) where user=’li4’; 修改其他用户的密码  ps:所有通过 user 表的修改必须用 flush privileges;命令才能生效<br>update mysql.user set user=’li4’ where user=’wang5’; 修改用户名 ps:所有通过 user 表的修改，必须用 flush privileges;命令才能生效<br>drop user li4  ps:不要通过 delete from user uwhere user=’li4’ 进行删除，系统会有残留信息保留。</p>
<h2 id="用户权限查看"><a href="#用户权限查看" class="headerlink" title="用户权限查看"></a>用户权限查看</h2><p>select host,user,password,select_priv,insert_priv,drop_priv from mysql.user<br>​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​<img src="https://img-blog.csdnimg.cn/2020052016145825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>host :表示连接类型</li>
<li>% 表示所有远程通过 TCP 方式的连接</li>
<li>IP 地址 如 (192.168.1.2,127.0.0.1) 通过制定 ip 地址进行的 TCP 方式的连接</li>
<li>机器名 通过制定 i 网络中的机器名进行的 TCP 方式的连接</li>
<li>::1 IPv6 的本地 ip 地址 等同于 IPv4 的 127.0.0.1</li>
<li>localhost 本地方式通过命令行方式的连接 ，比如 mysql -u xxx -p 123xxx 方式的连接。</li>
<li>user:表示用户名 同一用户通过不同方式链接的权限是不一样的</li>
<li>password:密码 所有密码串通过 password(明文字符串) 生成的密文字符串。加密算法为 MYSQLSHA1 ，不可逆 。mysql 5.7 的密码保存到 authentication_string 字段中不再使用 password 字段。</li>
<li>权限查看 select_priv , insert_priv 等为该用户所拥有的权限。<h2 id="Mysql权限管理"><a href="#Mysql权限管理" class="headerlink" title="Mysql权限管理"></a>Mysql权限管理</h2><h3 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h3>命令：  grant 权限 1,权限 2,…权限 n on 数据库名称.表名称 to 用户名@用户地址 identified by‘连接口令’</li>
</ul>
<p>ps：  该权限如果发现没有该用户，则会直接新建一个用户。</p>
<p>示例：grant select,insert,delete,drop on atguigudb.* to li4@localhost ;给 li4 用户用本地命令行方式下，授予 atguigudb 这个库下的所有表的插删改查的权限。</p>
<h3 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h3><p>命令： show grants  查看当前用户权限<br>命令： revoke [权限 1,权限 2,…权限 n] on 库名.表名 from 用户名@用户地址 ; 收回权限命令<br>命令:    REVOKE ALL PRIVILEGES ON mysql.* FROM joe@localhost; 收回全库全表的所有权限<br>命令： REVOKE select,insert,update,delete ON mysql.* FROM joe@localhost; 收回 mysql 库下的所有表的插删改查权限<br>查看权限<br>命令：show grants; 查看当前用户权限<br>命令：select * from user ;</p>
<h1 id="Mysql架构"><a href="#Mysql架构" class="headerlink" title="Mysql架构"></a>Mysql架构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在<br>存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可<br>以根据业务的需求和实际需要选择合适的存储引擎。</p>
<h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的<br>通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证<br>安全接入的客户端提供线程。同样在该层上可以实现基于 SSL 的安全链接。服务器也会为安全接入的每个客户端验<br>证它所具有的操作权限。</p>
<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>Management Serveices &amp; Utilities 系统管理和控制工具<br>SQL Interface: SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface<br>Parser 解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析<br>Optimizer 查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有where 条件时，优化器来决定先投影还是先过滤。<br>Cache 和 Buffer 查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等</p>
<h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><pre><code>存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同</code></pre><p>的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><pre><code>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</code></pre><h2 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h2><pre><code>利用 show profile 可以查看 sql 的执行周期！</code></pre><h3 id="开启-profile"><a href="#开启-profile" class="headerlink" title="开启 profile"></a>开启 profile</h3><p>show variables like ‘%profiling%’;<br><img src="https://img-blog.csdnimg.cn/20200520161537388.png" alt="在这里插入图片描述"><br>如果没有开启，可以执行 set profiling=1 开启<br><img src="https://img-blog.csdnimg.cn/20200520161600594.png" alt="在这里插入图片描述"></p>
<h3 id="使用-profile"><a href="#使用-profile" class="headerlink" title="使用 profile"></a>使用 profile</h3><p>执行 show prifiles 命令，可以查看最近的几次查询。<br><img src="https://img-blog.csdnimg.cn/20200520161637451.png" alt="在这里插入图片描述"><br>根据 Query_ID,可以进一步执行 show profile cpu,block io for query Query_id 来查看 sql 的具体执行步骤。<br><img src="https://img-blog.csdnimg.cn/20200520161658300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><p>mysql 的查询流程大致是：<br>       mysql 客户端通过协议与 mysql 服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果，<br>否则进行语句解析,也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储 SELECT 语句以及<br>相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅<br>仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。<br>       语法解析器和预处理：首先 mysql 通过关键字将 SQL 语句进行解析，并生成一颗对应的“解析树”。mysql 解析<br>器将使用 mysql 语法规则验证和解析查询；预处理器则根据一些 mysql 规则进一步检查解析数是否合法。<br>       查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，<br>最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。<br>       然后，mysql 默认使用的 BTREE 索引，并且一个大致方向是:无论怎么折腾 sql，至少在目前来说，mysql 最多只<br>用到表中的一个索引。</p>
<h3 id="MyISAM-和-和-InnoDB"><a href="#MyISAM-和-和-InnoDB" class="headerlink" title="MyISAM 和 和 InnoDB"></a>MyISAM 和 和 InnoDB</h3><p><img src="https://img-blog.csdnimg.cn/20200520161733769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>InnoDB</strong>：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>
<p><strong>MyISAM</strong>：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。</p>
<p>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>索引</strong>（Index）是帮助 MySQL 高效获取数据的数据结构。可以得到索引的本质： <strong>索引是数据结构</strong>。可以简单理解为<strong>排好序的快速查找数据结构</strong><br><img src="https://img-blog.csdnimg.cn/20200520162050195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个 右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指 针，这样就可以运用 二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为 更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为 更新所带来的键值变化后的索引信息</li>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的<h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><h3 id="B-树（B树）"><a href="#B-树（B树）" class="headerlink" title="B-树（B树）"></a>B-树（B树）</h3>B树属于多叉树又名平衡多路查找树<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li>
</ul>
<p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p>
<p>（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p>
<p>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;<br><img src="https://img-blog.csdnimg.cn/2020052016323075.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的， 如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高</p>
<h3 id="B-树-B-tree"><a href="#B-树-B-tree" class="headerlink" title="B+树(B+tree)"></a>B+树(B+tree)</h3><p>相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找</p>
<h3 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h3><p>（1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</p>
<p>（2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p>
<p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
<p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;<br><img src="https://img-blog.csdnimg.cn/20200520163640981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="B树与B-树区别"><a href="#B树与B-树区别" class="headerlink" title="B树与B+树区别"></a>B树与B+树区别</h3><ol>
<li>B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只 有关键字和指向下一个节点的索引，记录只放在叶子节点中</li>
<li>在 B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录 的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B- 树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B-树多，树高比 B-树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到 一个记录所需的比较次数要比 B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故。 </li>
</ol>
<p><strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<ol>
<li>B+树的磁盘读写代价更低 B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就 越多。相对来说 IO 读写次数也就降低了。</li>
<li>B+树的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须 走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ol>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p><img src="https://img-blog.csdnimg.cn/20200520164146479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>聚簇索引优点</strong><br>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多 个数据块中提取数据，所以节省了大量的 io 操作<br><strong>聚簇索引的限制</strong><br>对于 mysql 数据库目前只有 innodb 数据引擎支持聚簇索引，而 Myisam 并不支持聚簇索引。 由于数据物理存储排序方式只能有一种，所以每个 Mysql 的表只能有一个聚簇索引。一般情况下就是 该表的主键。 为了充分利用聚簇索引的聚簇的特性，所以 innodb 表的主键列尽量选用有序的顺序 id，而不建议用 无序的 id，比如 uuid 这种</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h3><p>一个索引只包含单个列，一个表可以有多个单列索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//随表创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> AUTO_INCREMENT ,</span><br><span class="line">	customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">	customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>), </span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>), <span class="keyword">KEY</span> (customer_name) </span><br><span class="line">);</span><br><span class="line">//单独创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_customer_name <span class="keyword">ON</span> customer(customer_name);</span><br></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>索引列的值必须唯一，但允许有空值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//随表创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> AUTO_INCREMENT ,</span><br><span class="line">	customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">	customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>), </span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>), <span class="keyword">KEY</span> (customer_name), <span class="keyword">UNIQUE</span> (customer_no) </span><br><span class="line">);</span><br><span class="line">//单独建立</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idx_customer_no <span class="keyword">ON</span> customer(customer_no);</span><br></pre></td></tr></table></figure>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//随表创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> AUTO_INCREMENT ,</span><br><span class="line">	customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">	customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>), </span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br><span class="line">//单独创建</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer <span class="keyword">add</span> PRIMARY <span class="keyword">KEY</span> customer(customer_no);</span><br><span class="line">//删除索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer <span class="keyword">drop</span> PRIMARY <span class="keyword">KEY</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>一个索引包含多个列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//随表创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> AUTO_INCREMENT ,</span><br><span class="line">	customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">	customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>), </span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>), </span><br><span class="line">	<span class="keyword">KEY</span> (customer_name), </span><br><span class="line">	<span class="keyword">UNIQUE</span> (customer_name), </span><br><span class="line">	<span class="keyword">KEY</span> (customer_no,customer_name) </span><br><span class="line">);</span><br><span class="line">//单独创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_no_name <span class="keyword">ON</span> customer(customer_no,customer_name);</span><br></pre></td></tr></table></figure>
<h2 id="索引应用场景"><a href="#索引应用场景" class="headerlink" title="索引应用场景"></a>索引应用场景</h2><h3 id="适合创建场景"><a href="#适合创建场景" class="headerlink" title="适合创建场景"></a>适合创建场景</h3><ol>
<li>主键自动建立唯一索引； </li>
<li>频繁作为查询条件的字段应该创建索引 </li>
<li>查询中与其它表关联的字段，外键关系建立索引 </li>
<li>单键/组合索引的选择问题， 组合索引性价比更高 </li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度 </li>
<li>查询中统计或者分组字段<h3 id="不适合创建的场景"><a href="#不适合创建的场景" class="headerlink" title="不适合创建的场景"></a>不适合创建的场景</h3></li>
<li>表记录太少 </li>
<li>经常增删改的表或者字段</li>
<li>Where 条件里用不到的字段不创建索引 </li>
<li>过滤性不好的不适合建索引<h1 id="Explain性能分析"><a href="#Explain性能分析" class="headerlink" title="Explain性能分析"></a>Explain性能分析</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2>使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分 析你的查询语句或是表结构的性能瓶颈。<br><img src="https://img-blog.csdnimg.cn/20200520165601328.png" alt="在这里插入图片描述"><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2>表示查询中执行 select 子句或操作表的顺序<h3 id="id-相同"><a href="#id-相同" class="headerlink" title="id 相同"></a>id 相同</h3>执行顺序由上至下<img src="https://img-blog.csdnimg.cn/20200520165731469.png" alt="在这里插入图片描述"><h2 id="id-不同"><a href="#id-不同" class="headerlink" title="id 不同"></a>id 不同</h2>如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行<img src="https://img-blog.csdnimg.cn/20200520165815825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="有相同也有不同"><a href="#有相同也有不同" class="headerlink" title="有相同也有不同"></a>有相同也有不同</h3>id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行衍生 = DERIVED<img src="https://img-blog.csdnimg.cn/20200520165915293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p><strong>id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好</strong></p>
<h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><p>select_type 代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询<br>|select_type 属性|含义|<br>|:————–:|:—————:|<br>|SIMPLE| 简单的 select 查询,查询中不包含子查询或者 UNION|<br>|PRIMARY|查询中若包含任何复杂的子部分，最外层查询则被标记为 Primary|<br>|DERIVED|在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里|<br>|SUBQUERY|在SELECT或WHERE列表中包含了子查询|<br>|DEPEDENT SUBQUERY|在SELECT或WHERE列表中包含了子查询,子查询基于外层|<br>|UNCACHEABLE SUBQUERY|无法使用缓存的子查询|<br>|UNION|若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED|<br>|UNION RESULT|从UNION表获取结果的SELECT|</p>
<h3 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h3><p>SIMPLE 代表单表查询<br><img src="https://img-blog.csdnimg.cn/20200528165037586.png" alt="在这里插入图片描述"></p>
<h3 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h3><p>查询中若包含任何复杂的子部分，最外层查询则被标记为 Primary<br><img src="https://img-blog.csdnimg.cn/20200528165108669.png" alt="在这里插入图片描述"></p>
<h3 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h3><p>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生),MySQL 会递归执行这些子查询, 把结果放在临时表里</p>
<h3 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h3><p>在 SELECT 或 WHERE 列表中包含了子查询<img src="https://img-blog.csdnimg.cn/20200528165154727.png" alt="在这里插入图片描述"></p>
<h3 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h3><p>在 SELECT 或 WHERE 列表中包含了子查询,子查询基于外层，都是 where 后面的条件，subquery 是单个值，dependent subquery 是一组值<br><img src="https://img-blog.csdnimg.cn/20200528165236202.png" alt="在这里插入图片描述"></p>
<h3 id="UNCACHEABLE-SUBQUREY"><a href="#UNCACHEABLE-SUBQUREY" class="headerlink" title="UNCACHEABLE SUBQUREY"></a>UNCACHEABLE SUBQUREY</h3><p>当使用了@@来引用系统变量的时候，不会使用缓存<br><img src="https://img-blog.csdnimg.cn/20200528165320231.png" alt="在这里插入图片描述"></p>
<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中,外层 SELECT 将被标记为：DERIVED<br><img src="https://img-blog.csdnimg.cn/20200528165401484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="UNION-RESULT"><a href="#UNION-RESULT" class="headerlink" title="UNION RESULT"></a>UNION RESULT</h3><p>从 UNION 表获取结果的 SELECT</p>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>这个数据是基于哪张表的</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type 是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏依次是：<br><strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong><br>一般来说，得保证查询至少达到 range 级别，最好能达到 ref</p>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>表示通过索引一次就找到了,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快 如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</p>
<h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描<br><img src="https://img-blog.csdnimg.cn/20200528171350951.png" alt="在这里插入图片描述"></p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>非唯一性索引扫描，返回匹配某个单独值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行， 然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体<br>没用索引前：<br><img src="https://img-blog.csdnimg.cn/20200528171452184.png" alt="在这里插入图片描述"><br>建立索引后：<br><img src="https://img-blog.csdnimg.cn/20200528171546561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而 结束语另一点，不用扫描全部索引<br><img src="https://img-blog.csdnimg.cn/20200603134033258.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603134049892.png" alt="在这里插入图片描述"></p>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组<br><img src="https://img-blog.csdnimg.cn/20200603134432699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>Full Table Scan，将遍历全表以找到匹配的行<br><img src="https://img-blog.csdnimg.cn/20200603134503782.png" alt="在这里插入图片描述"></p>
<h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h3><p>在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的 sql 中<br><img src="https://img-blog.csdnimg.cn/20200603134531835.png" alt="在这里插入图片描述"></p>
<h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><p>对于某个字段既需要关联条件，也需要 null 值得情况下。查询优化器会选择用 ref_or_null 连接查询<br><img src="https://img-blog.csdnimg.cn/20200603134604725.png" alt="在这里插入图片描述"></p>
<h3 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h3><p><img src="https://img-blog.csdnimg.cn/2020060313463757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603134648984.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603134710384.png" alt="在这里插入图片描述"></p>
<h3 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h3><p>该联接类型类似于 index_subquery。 子查询中的唯一索引<br><img src="https://img-blog.csdnimg.cn/20200603134746360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>备注：一般来说，得保证查询至少达到range级别，最好能达到ref</strong></p>
<h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><p>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一 定被查询实际使用</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的 利用上了索引。ken_len 越长，说明索引使用的越充分<br><img src="https://img-blog.csdnimg.cn/20200603134904302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603134919838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如何计算： ①先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20 ②如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 要乘 3,GBK 要乘 2， ③varchar 这种动态字符串要加 2 个字节 ④允许为空的字段要加 1 个字节 第一组：key_len=age 的字节长度+name 的字节长度=4+1 + ( 20*3+2)=5+62=67 第二组：key_len=age 的字节长度=4+1=5</p>
<h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值<br><img src="https://img-blog.csdnimg.cn/20200603135004728.png" alt="在这里插入图片描述"></p>
<h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。越少越好！<br><img src="https://img-blog.csdnimg.cn/20200603135030774.png" alt="在这里插入图片描述"></p>
<h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>其他的额外重要的信息</p>
<h3 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h3><p>说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引 完成的排序操作称为“文件排序”。 出现 filesort 的情况<br><img src="https://img-blog.csdnimg.cn/20200603135121380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>优化后，不再出现 filesort 的情况：<br><img src="https://img-blog.csdnimg.cn/20200603135150244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</strong></p>
<h3 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h3><p>使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by<br>优化前：<br><img src="https://img-blog.csdnimg.cn/20200603135253952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>优化后：<br><img src="https://img-blog.csdnimg.cn/20200603135318386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h3><p>Using index 代表表示相应的 select 操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！ 如果同时出现 using where，表明索引被用来执行索引键值的查找;如果没有同时出现 using where，表明索引只是 用来读取数据而非利用索引执行查找。 利用索引进行了排序或分组</p>
<h3 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h3><p>表明使用了 where 过滤</p>
<h3 id="Using-join-buffer"><a href="#Using-join-buffer" class="headerlink" title="Using join buffer"></a>Using join buffer</h3><p><img src="https://img-blog.csdnimg.cn/20200603135412369.png" alt="在这里插入图片描述"><br>使用了连接缓存</p>
<h3 id="impossible-where"><a href="#impossible-where" class="headerlink" title="impossible where"></a>impossible where</h3><p>where 子句的值总是 false，不能用来获取任何元组<br><img src="https://img-blog.csdnimg.cn/20200603135449159.png" alt="在这里插入图片描述"></p>
<h3 id="select-tables-optimized-away"><a href="#select-tables-optimized-away" class="headerlink" title="select tables optimized away"></a>select tables optimized away</h3><p>在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操 作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化<br>在 innodb 中：<img src="https://img-blog.csdnimg.cn/20200603135526356.png" alt="在这里插入图片描述"><br>在 Myisam 中：<br><img src="https://img-blog.csdnimg.cn/20200603135546312.png" alt="在这里插入图片描述"></p>
<h1 id="批量脚本"><a href="#批量脚本" class="headerlink" title="批量脚本"></a>批量脚本</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="随机产生字符串"><a href="#随机产生字符串" class="headerlink" title="随机产生字符串"></a>随机产生字符串</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$ </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'</span>; </span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>; </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line">WHILE i &lt; n </span><br><span class="line"><span class="keyword">DO</span> </span><br><span class="line">	<span class="keyword">SET</span> return_str =<span class="keyword">CONCAT</span>(return_str,<span class="keyword">SUBSTRING</span>(chars_str,<span class="keyword">FLOOR</span>(<span class="number">1</span>+<span class="keyword">RAND</span>()*<span class="number">52</span>),<span class="number">1</span>)); 				</span><br><span class="line">	<span class="keyword">SET</span> i = i + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>; </span><br><span class="line">RETURN return_str; <span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure>
<h3 id="随机产生编号"><a href="#随机产生编号" class="headerlink" title="随机产生编号"></a>随机产生编号</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于随机产生多少到多少的编号 </span></span><br><span class="line">DELIMITER $$ </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="built_in">INT</span> ,to_num <span class="built_in">INT</span>) </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INT</span>(<span class="number">11</span>) </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">SET</span> i = <span class="keyword">FLOOR</span>(from_num +<span class="keyword">RAND</span>()*(to_num -from_num+<span class="number">1</span>)) ; </span><br><span class="line">RETURN i; </span><br><span class="line"><span class="keyword">END</span>$$</span><br></pre></td></tr></table></figure>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><h3 id="创建往-emp-表中插入数据的存储过程"><a href="#创建往-emp-表中插入数据的存储过程" class="headerlink" title="创建往 emp 表中插入数据的存储过程"></a>创建往 emp 表中插入数据的存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$ </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_emp( <span class="keyword">START</span> <span class="built_in">INT</span> , max_num <span class="built_in">INT</span> ) </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="comment">#set autocommit =0 把 autocommit 设置成 0 SET autocommit = 0; </span></span><br><span class="line">REPEAT <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (empno, <span class="keyword">NAME</span> ,age ,deptid ) <span class="keyword">VALUES</span> ((<span class="keyword">START</span>+i) ,rand_string(<span class="number">6</span>) , rand_num(<span class="number">30</span>,<span class="number">50</span>),rand_num(<span class="number">1</span>,<span class="number">10000</span>)); </span><br><span class="line">UNTIL i = max_num </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>; </span><br><span class="line"><span class="keyword">COMMIT</span>; </span><br><span class="line"><span class="keyword">END</span>$$ </span><br><span class="line"><span class="comment">#删除 </span></span><br><span class="line"><span class="comment"># DELIMITER ; </span></span><br><span class="line"><span class="comment"># drop PROCEDURE insert_emp;</span></span><br></pre></td></tr></table></figure>
<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行存储过程，往 dept 表添加 1 万条数据 DELIMITER ; </span></span><br><span class="line"><span class="keyword">CALL</span> insert_dept(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="批量删除某个表上的所有索引"><a href="#批量删除某个表上的所有索引" class="headerlink" title="批量删除某个表上的所有索引"></a>批量删除某个表上的所有索引</h2><h3 id="删除索引的存储过程"><a href="#删除索引的存储过程" class="headerlink" title="删除索引的存储过程"></a>删除索引的存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$ </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`proc_drop_index`</span>(dbname <span class="built_in">VARCHAR</span>(<span class="number">200</span>),tablename <span class="built_in">VARCHAR</span>(<span class="number">200</span>)) </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">DECLARE</span> ct <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">DECLARE</span> _index <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>; </span><br><span class="line"><span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> index_name <span class="keyword">FROM</span> information_schema.STATISTICS <span class="keyword">WHERE</span> table_schema=dbname <span class="keyword">AND</span> table_name=tablename <span class="keyword">AND</span> seq_in_index=<span class="number">1</span> <span class="keyword">AND</span> index_name &lt;&gt;<span class="string">'PRIMARY'</span> ; </span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">set</span> done=<span class="number">2</span> ; </span><br><span class="line">OPEN _cur; </span><br><span class="line">FETCH _cur INTO _index; </span><br><span class="line">WHILE _index&lt;&gt;'' </span><br><span class="line"><span class="keyword">DO</span> <span class="keyword">SET</span> @<span class="keyword">str</span> = <span class="keyword">CONCAT</span>(<span class="string">"drop index "</span>,_index,<span class="string">" on "</span>,tablename ); <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> @<span class="keyword">str</span> ; </span><br><span class="line"><span class="keyword">EXECUTE</span> sql_str; </span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str; </span><br><span class="line"><span class="keyword">SET</span> _index=<span class="string">''</span>; </span><br><span class="line">FETCH _cur INTO _index; </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>; CLOSE _cur; </span><br><span class="line"><span class="keyword">END</span>$$</span><br></pre></td></tr></table></figure>
<h3 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h3><p>调用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> proc_drop_index(<span class="string">"dbname"</span>,<span class="string">"tablename"</span>);</span><br></pre></td></tr></table></figure>
<h1 id="单表使用索引常见的索引失效"><a href="#单表使用索引常见的索引失效" class="headerlink" title="单表使用索引常见的索引失效"></a>单表使用索引常见的索引失效</h1><h2 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h2><h3 id="有以下-SQL-语句"><a href="#有以下-SQL-语句" class="headerlink" title="有以下 SQL 语句"></a>有以下 SQL 语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age=<span class="number">30</span> </span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age=<span class="number">30</span> <span class="keyword">and</span> deptid=<span class="number">4</span> </span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age=<span class="number">30</span> <span class="keyword">and</span> deptid=<span class="number">4</span> <span class="keyword">AND</span> emp.name = <span class="string">'abcd'</span></span><br></pre></td></tr></table></figure>
<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_age_deptid_name <span class="keyword">ON</span> emp(age,deptid,<span class="keyword">NAME</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200603140933972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查询的字段按照顺序在索引中都可以匹配到<br><img src="https://img-blog.csdnimg.cn/20200603141013659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>SQL 中查询字段的顺序，跟使用索引中字段的顺序，没有关系。优化器会在不影响 SQL 执行结果的前提下，自动地优化</p>
<h2 id="最左前置法则"><a href="#最左前置法则" class="headerlink" title="最左前置法则"></a>最左前置法则</h2><p><img src="https://img-blog.csdnimg.cn/20200603141427591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查询字段与索引字段顺序的不同会导致索引无法充分使用，甚至索引失效<br><strong>原因</strong>：使用复合索引，需要遵循最佳左前缀法则，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。<br><strong>结论</strong>：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</p>
<h2 id="不要在索引列上做任何计算"><a href="#不要在索引列上做任何计算" class="headerlink" title="不要在索引列上做任何计算"></a>不要在索引列上做任何计算</h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），会导致索引失效而转向全表扫描</p>
<h3 id="索引列不能有范围查询"><a href="#索引列不能有范围查询" class="headerlink" title="索引列不能有范围查询"></a>索引列不能有范围查询</h3><p><img src="https://img-blog.csdnimg.cn/20200603142009981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>建议：将可能做范围查询的字段的索引顺序放在最后</p>
<h2 id="尽量使用覆盖索引"><a href="#尽量使用覆盖索引" class="headerlink" title="尽量使用覆盖索引"></a>尽量使用覆盖索引</h2><p><img src="https://img-blog.csdnimg.cn/20200603142100283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="使用不等于-或者-lt-gt-的时候"><a href="#使用不等于-或者-lt-gt-的时候" class="headerlink" title="使用不等于(!= 或者&lt;&gt;)的时候"></a>使用不等于(!= 或者&lt;&gt;)的时候</h3><p>mysql 在使用不等于(!= 或者&lt;&gt;)时，有时会无法使用索引会导致全表扫描<br><img src="https://img-blog.csdnimg.cn/20200603142301316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="字段的-is-not-null-和-is-null"><a href="#字段的-is-not-null-和-is-null" class="headerlink" title="字段的 is not null 和 is null"></a>字段的 is not null 和 is null</h3><p><img src="https://img-blog.csdnimg.cn/20200603142323728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当字段允许为 Null 的条件下：<br><img src="https://img-blog.csdnimg.cn/20200603142358666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>is not null 用不到索引，is null 可以用到索引</p>
<h3 id="like-的前后模糊匹配"><a href="#like-的前后模糊匹配" class="headerlink" title="like 的前后模糊匹配"></a>like 的前后模糊匹配</h3><p><img src="https://img-blog.csdnimg.cn/20200603142506394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>只有后缀查询可以使用索引</p>
<h3 id="减少使用or"><a href="#减少使用or" class="headerlink" title="减少使用or"></a>减少使用or</h3><p><img src="https://img-blog.csdnimg.cn/20200603142857984.png" alt="在这里插入图片描述"><br>使用 union all 或者 union 来替代：<br><img src="https://img-blog.csdnimg.cn/20200603142925477.png" alt="在这里插入图片描述"></p>
<h1 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h1><h2 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">class</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> class.card = book.card;</span><br></pre></td></tr></table></figure>
<p>查询<br><img src="https://img-blog.csdnimg.cn/20200603144934560.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603150257284.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603150313537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>①在优化关联查询时，只有在被驱动表上建立索引才有效！<br>②left join 时，左侧的为驱动表，右侧为被驱动表</p>
<h2 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h2><p>④inner join 时，mysql 会自己帮你把小结果集的表选为驱动表。 ⑤straight_join: 效果和 inner join 一样，但是会强制将左侧作为驱动表</p>
<h2 id="四个关联查询案例分析"><a href="#四个关联查询案例分析" class="headerlink" title="四个关联查询案例分析"></a>四个关联查询案例分析</h2><p><img src="https://img-blog.csdnimg.cn/20200603150510382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603150537975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述两个案例，第一个查询效率较高，且有优化的余地。第二个案例中，子查询作为被驱动表，由于子查询是虚表， 无法建立索引，因此不能优化<br><strong>结论</strong>：子查询尽量不要放在被驱动表，有可能使用不到索引； left join时，尽量让实体表作为被驱动表。</p>
<h1 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h1><p>取所有不为掌门人的员工，按年龄分组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	age <span class="keyword">as</span> <span class="string">'年龄'</span>, <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="string">'人数'</span> </span><br><span class="line"><span class="keyword">from</span> t_emp </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> ceo <span class="keyword">from</span> t_dept <span class="keyword">where</span> ceo <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>) <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200603152327150.png" alt="在这里插入图片描述"><br>如何优化？<br>①解决 dept 表的全表扫描，建立 ceo 字段的索引：<br><img src="https://img-blog.csdnimg.cn/20200603152403966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时，再次查询：<br><img src="https://img-blog.csdnimg.cn/2020060315243831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>②进一步优化，替换 not in。 上述 SQL 可以替换为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	age <span class="keyword">as</span> <span class="string">'年龄'</span>,<span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="string">'人数'</span> </span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.id=d.ceo </span><br><span class="line"><span class="keyword">where</span> d.id <span class="keyword">is</span> <span class="literal">null</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200603152538191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>结论： 在范围判断时，尽量不要使用 not in 和 not exists，使用 left join on xxx is null 代替</p>
<h1 id="排序分组优化"><a href="#排序分组优化" class="headerlink" title="排序分组优化"></a>排序分组优化</h1><h2 id="索引的字段必须由where或limit处理"><a href="#索引的字段必须由where或limit处理" class="headerlink" title="索引的字段必须由where或limit处理"></a>索引的字段必须由where或limit处理</h2><p>where 条件和 on 的判断这些过滤条件，作为优先优化的部门，是要被先考虑的！其次，如果有分组和排序，那么 也要考虑 grouo by 和 order by<br><img src="https://img-blog.csdnimg.cn/20200603153830382.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200603153852109.png" alt="在这里插入图片描述"><br>using filesort 说明进行了手工排序！原因在于没有 where 作为过滤条件<br><img src="https://img-blog.csdnimg.cn/20200603153911574.png" alt="在这里插入图片描述"><br><strong>结论</strong>： 无过滤，不索引。where，limt 都相当于一种过滤条件，所以才能使用上索引</p>
<h2 id="顺序错，必排序"><a href="#顺序错，必排序" class="headerlink" title="顺序错，必排序"></a>顺序错，必排序</h2><p>①explain select * from emp where age=45 order by deptid,name;<br><img src="https://img-blog.csdnimg.cn/20200603154105332.png" alt="在这里插入图片描述"><br>②explain select * from emp where age=45 order by deptid,empno;<br><img src="https://img-blog.csdnimg.cn/20200603154131635.png" alt="在这里插入图片描述"><br>empno 字段并没有建立索引，因此也无法用到索引，此字段需要排序<br>③explain select * from emp where age=45 order by name,deptid;<br><img src="https://img-blog.csdnimg.cn/20200603154202709.png" alt="在这里插入图片描述"><br>where 两侧列的顺序可以变换，效果相同，但是 order by 列的顺序不能随便变换！<br>④explain select * from emp where deptid=45 order by age;<br><img src="https://img-blog.csdnimg.cn/20200603154227296.png" alt="在这里插入图片描述"><br>deptid 作为过滤条件的字段，无法使用索引，因此排序没法用上索引</p>
<h2 id="方向反，必排序"><a href="#方向反，必排序" class="headerlink" title="方向反，必排序"></a>方向反，必排序</h2><p>①explain select * from emp where age=45 order by deptid desc, name desc ;<br><img src="https://img-blog.csdnimg.cn/20200603155603443.png" alt="在这里插入图片描述"><br>如果可以用上索引的字段都使用正序或者逆序，实际上是没有任何影响的，无非将结果集调换顺序。<br>②explain select * from emp where age=45 order by deptid asc, name desc ;<br><img src="https://img-blog.csdnimg.cn/2020060315563032.png" alt="在这里插入图片描述"><br>如果排序的字段，顺序有差异，就需要将差异的部分，进行一次倒置顺序，因此还是需要手动排序的</p>
<h2 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h2><p>①首先，清除 emp 上面的所有索引，只保留主键索引！ </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_age_deptid_name <span class="keyword">on</span> emp;</span><br></pre></td></tr></table></figure>
<p>②查询：年龄为 30 岁的，且员工编号小于 101000 的用户，按用户名称排序 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> </span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	SQL_NO_CACHE * </span><br><span class="line"><span class="keyword">FROM</span> emp </span><br><span class="line"><span class="keyword">WHERE</span> age =<span class="number">30</span> <span class="keyword">AND</span> empno &lt;<span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">NAME</span> ;</span><br></pre></td></tr></table></figure>
<p>③全表扫描肯定是不被允许的，因此我们要考虑优化。<br>思路：首先需要让 where 的过滤条件，用上索引； 查询中，age.empno 是查询的过滤条件，而 name 则是排序的字段，因此我们来创建一个此三个字段的复合索引： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_age_empno_name <span class="keyword">on</span> emp(age,empno,<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020060315594321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>再次查询，发现 using filesort 依然存在。<br>原因： empno 是范围查询，因此导致了索引失效，所以 name 字段无法使用索引排序。 所以，三个字段的符合索引，没有意义，因为 empno 和 name 字段只能选择其一<br>④解决： 鱼与熊掌不可兼得，因此，要么选择 empno,要么选择 name drop index idx_age_empno_name on emp; create index idx_age_name on emp(age,name); create index idx_age_empno on emp(age,empno);<br>两个索引同时存在，mysql 会选择哪个？<br><img src="https://img-blog.csdnimg.cn/20200604163501914.png" alt="在这里插入图片描述"><br>explain SELECT SQL_NO_CACHE * FROM emp use index(idx_age_name) WHERE age =30 AND empno &lt;101000 ORDER BY NAME ;<br><img src="https://img-blog.csdnimg.cn/20200604163521516.png" alt="在这里插入图片描述"><br>原因：所有的排序都是在条件过滤之后才执行的，所以如果条件过滤了大部分数据的话，几百几千条数据进行排序 其实并不是很消耗性能，即使索引优化了排序但实际提升性能很有限。 相对的 empno&lt;101000 这个条件如果没 有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，使用 empno 字段的范围查询，过滤性更好 （empno 从 100000 开始）！ 结论： 当范围条件和 group by 或者 order by 的字段出现二选一时 ，优先观察条件字段的过滤数量，如果过滤的 数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</p>
<h2 id="using-filesort"><a href="#using-filesort" class="headerlink" title="using filesort"></a>using filesort</h2><h3 id="mysql排序算法"><a href="#mysql排序算法" class="headerlink" title="mysql排序算法"></a>mysql排序算法</h3><ol>
<li><strong>双路排序</strong><br>MySQL 4.1 之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，读取行指针和 orderby 列，对他 们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。 从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段。 简单来说，取一批数据，要对磁盘进行了两次扫描，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序。</li>
<li><strong>单路排序</strong><br>从磁盘读取查询需要的所有列，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了</li>
<li><strong>单路排序的问题</strong><br>由于单路是后出的，总体而言好过双路。但是存在以下问题： 在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出, 所以有可能取出的数 据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多 路合并），排完再取取 sort_buffer 容量大小，再排……从而多次 I/O。<h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3>①<strong>增大 sort_butter_size 参数的设置</strong><br>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的 1M-8M 之间调整。<br>②<strong>增大 max_length_for_sort_data 参数的设置</strong><br>mysql 使用单路排序的前提是排序的字段大小要小于 <strong>max_length_for_sort_data</strong>。 提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 <strong>sort_buffer_size</strong> 的概率就增大， 明显症状是高的磁盘 I/O 活动和低的处理器使用率。（1024-8192 之间调整）。<br>③<strong>减少 select 后面的查询的字段</strong><br>当 Query 的字段大小总和小于 max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的 算法——单路排序， 否则用老算法——多路排序。 两种算法的数据都有可能超出 sort_buffer 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O， 但是用单路排序算法的风险会更大一些,所以要提高 sort_buffer_size。<h1 id="截取查询分析"><a href="#截取查询分析" class="headerlink" title="截取查询分析"></a>截取查询分析</h1><h2 id="慢日志查询"><a href="#慢日志查询" class="headerlink" title="慢日志查询"></a>慢日志查询</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>（1）MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具 体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。<br>（2）具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句。 （3）由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能 收集超过5秒的sql，结合之前explain进行全面分析。<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。<br>如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件<br>（1） 开启设置<table>
<thead>
<tr>
<th align="center">SQL 语句</th>
<th align="center">描述</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SHOW VARIABLES LIKE ‘%slow_query_log%’;</td>
<td align="center">查看慢查询日志是否开启</td>
<td align="center">默认情况下 slow_query_log 的值为 OFF， 表示慢查询日志是禁用的</td>
</tr>
<tr>
<td align="center">set global slow_query_log=1;</td>
<td align="center">开启慢查询日志</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SHOW VARIABLES LIKE ‘long_query_time%’;</td>
<td align="center">查看慢查询设定阈值</td>
<td align="center">单位秒</td>
</tr>
<tr>
<td align="center">set long_query_time=1</td>
<td align="center">设定慢查询阈值</td>
<td align="center">单位秒</td>
</tr>
<tr>
<td align="center">（2） 如永久生效需要修改配置文件 my.cnf 中[mysqld]下配置</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] slow_query_log=1 </span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-slow.log </span><br><span class="line">long_query_time=3 log_output=FILE</span><br></pre></td></tr></table></figure>
<p>（3） 运行查询时间长的 sql，打开慢查询日志查看</p>
<h3 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具mysqldumpslow</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">得到返回记录集最多的 10 个 SQL </span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log </span><br><span class="line">得到访问次数最多的 10 个 SQL </span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log </span><br><span class="line">得到按照时间排序的前 10 条里面含有左连接的查询语句 </span><br><span class="line">mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log </span><br><span class="line">另外建议在使用这些命令时结合 | 和 more 使用 ，否则有可能出现爆屏情况 </span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>
<h2 id="SHOW-PROCESSLIST"><a href="#SHOW-PROCESSLIST" class="headerlink" title="SHOW PROCESSLIST"></a>SHOW PROCESSLIST</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>查询 mysql 进程列表，可以杀掉故障进程</p>
<h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><p><img src="https://img-blog.csdnimg.cn/2020061815210559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="工具和技巧拾遗"><a href="#工具和技巧拾遗" class="headerlink" title="工具和技巧拾遗"></a>工具和技巧拾遗</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>将一段查询 sql 封装为一个虚拟的表。 这个虚拟表只保存了 sql 逻辑，不会保存任何查询结果。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>（1）封装复杂 sql 语句，提高复用性<br>（2）逻辑放在数据库上面，更新不需要发布程序，面对频繁的需求变更更灵活</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>（1）slave 会从 master 读取 binlog 来进行数据同步<br>（2）三步骤+原理图<br><img src="https://img-blog.csdnimg.cn/2020061815280298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>MySQL 复制过程分成三步：<br>(1)master 将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；<br>(2)slave 将 master 的 binary log events 拷贝到它的中继日志（relay log）<br>(3)slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL 复制是异步的且串行化的</p>
<h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>（1）每个 slave 只有一个 master<br>（2）每个 slave 只能有一个唯一的服务器 ID<br>（3）每个 master 可以有多个 salve</p>
<h2 id="最大问题"><a href="#最大问题" class="headerlink" title="最大问题"></a>最大问题</h2><p>因为发生多次 IO，存在延时问题</p>
<h2 id="一主一从常见配置"><a href="#一主一从常见配置" class="headerlink" title="一主一从常见配置"></a>一主一从常见配置</h2><p>（1） mysql 版本一致且后台以服务运行<br>（2） 主从都配置在[mysqld]结点下，都是小写 主机修改 my.ini 配置文件<br><img src="https://img-blog.csdnimg.cn/20200618152942235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一 ID </span></span><br><span class="line">server-id=1 </span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line">log-bin=自己本地的路径/data/mysqlbin </span><br><span class="line">log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin </span><br><span class="line"><span class="comment">#设置不要复制的数据库 </span></span><br><span class="line">binlog-ignore-db=mysql </span><br><span class="line"><span class="comment">#设置需要复制的数据库 </span></span><br><span class="line">binlog-<span class="keyword">do</span>-db=需要复制的主数据库名字 </span><br><span class="line"><span class="comment">#设置 logbin 格式 </span></span><br><span class="line">binlog_format=<span class="keyword">STATEMENT</span>（默认）</span><br></pre></td></tr></table></figure>
<p>mysql 主从复制起始时，从机不继承主机数据<br>（3） logbin 格式 binlog_format=STATEMENT（默认） binlog_format=ROW binlog_format=MIXED<br>（4） 从机配置文件修改 my.cnf 的[mysqld]栏位下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从机服务 id </span></span><br><span class="line">server-id = 2 </span><br><span class="line"><span class="comment">#注意 my.cnf 中有 </span></span><br><span class="line">server-id = 1 </span><br><span class="line"><span class="comment">#设置中继日志 </span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>
<p>（5） 因修改过配置文件，请主机+从机都重启后台 mysql 服务<br>（6） 主机从机都关闭防火墙、安全工具（腾讯管家等）<br>（7） 在 Windows 主机上建立帐户并授权 slave</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建用户，并授权 </span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'备份账号'</span>@<span class="string">'从机器数据库 IP'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200618153454563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（8） 查询 master 的状态，并记录下 File 和 Position 的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询 master 的状态 </span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200618153540451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>执行完此步骤后不要再操作主服务器 MYSQL，防止主服务器状态值变化 （9） 在 Linux 从机上配置需要复制的主机</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询 master 的状态 </span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'主机 IP'</span>,</span><br><span class="line">MASTER_USER=<span class="string">'创建用户名'</span>,</span><br><span class="line">MASTER_PASSWORD=<span class="string">'创建的密码'</span>, </span><br><span class="line">MASTER_LOG_FILE=<span class="string">'File 名字'</span>,</span><br><span class="line">MASTER_LOG_POS=<span class="keyword">Position</span> 数字;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200618153639591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（10） 启动从服务器复制功能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>; </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>\G;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200618153738619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDAyNTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面两个参数都是 Yes，则说明主从配置成功！<br>（11） 主机新建库、新建表、insert 记录，从机复制<br>（12） 如何停止从服务复制功能   stop slave;</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">xcr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/08/06/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://yoursite.com/2020/08/06/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/08/06/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Redis学习笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/27/%E4%BD%BF%E7%94%A8Java%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8shell%E8%84%9A%E6%9C%AC%E9%87%8D%E5%90%AFtomcat/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">使用Java语言调用shell脚本重启tomcat</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'VJOs4EVRhHLbfnfAm9ezhk2c-gzGzoHsz',
  appKey: 'hQrvQk5qQ0QfLhow1uxyhcub',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By xcr</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>